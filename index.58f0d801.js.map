{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,Q,S,C,C,C,E,E,E,O,C,W,I,E,A,G,E,G,E,E,O,C,U,I,E,A,G,E,GCEA,IAcA,EACA,EAfI,EAAU,CAAC,EAcf,EAbA,SAAkB,CAAK,EAErB,IAAK,IADD,EAAO,OAAO,IAAA,CAAK,GACd,EAAI,EAAG,EAAI,EAAK,MAAA,CAAQ,IAC/B,CAAO,CAAC,CAAI,CAAC,EAAE,CAAC,CAAG,CAAK,CAAC,CAAI,CAAC,EAAE,CAAC,AAErC,EASA,EARA,SAAiB,CAAE,EACjB,IAAI,EAAW,CAAO,CAAC,EAAG,CAC1B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,CACT,C,GCfA,AAAA,EAAA,SAAA,QAAA,CAA8C,KAAK,KAAA,CAAM,uG,I,E,C,EIAzD,EAAiB,IAAA,IAAoB,AAAA,EAAA,SAAA,OAAA,CAA6C,SAAA,YAAA,GAAA,EAAU,QAA5F,GHIA,IAAI,EAAe,EACf,EAAY,CA8IhB,GAAE;AACF,6DAA6D;AAC7D,eAAe;AACf,EAAE;AACF,SAAS,EAAW,CAAE,CAAE,CAAI,CAAE,CAAM,EAClC,IAAM,EAAS,EAAG,YAAA,CAAa,UAU/B,kCAAkC;AAElC,CAVA,uCAAuC;AAEvC,EAAG,YAAA,CAAa,EAAQ,GAExB,6BAA6B;AAE7B,EAAG,aAAA,CAAc,GAIZ,EAAG,kBAAA,CAAmB,EAAQ,EAAG,cAAA,GAQ/B,GAPL,MACE,CAAC,yCAAyC,EAAE,EAAG,gBAAA,CAAiB,GAAQ,CAAC,EAE3E,EAAG,YAAA,CAAa,GACT,MAIX,EAtKA,AAEA,e,EA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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-4023ba87348dbe4c.js","src/webgl-demo.js","src/init-buffers.js","src/draw-scene.js","node_modules/@parcel/runtime-js/lib/runtime-dea32c6ac5b0340b.js"],"sourcesContent":["function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\nparcelRequire.register(\"27Lyk\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $18c11f3350a906ea$export$6503ec6e8aabbaf, (v) => $18c11f3350a906ea$export$6503ec6e8aabbaf = v);\n$parcel$export(module.exports, \"resolve\", () => $18c11f3350a906ea$export$f7ad0328861e2f03, (v) => $18c11f3350a906ea$export$f7ad0328861e2f03 = v);\nvar $18c11f3350a906ea$export$6503ec6e8aabbaf;\nvar $18c11f3350a906ea$export$f7ad0328861e2f03;\n\"use strict\";\nvar $18c11f3350a906ea$var$mapping = {};\nfunction $18c11f3350a906ea$var$register(pairs) {\n    var keys = Object.keys(pairs);\n    for(var i = 0; i < keys.length; i++)$18c11f3350a906ea$var$mapping[keys[i]] = pairs[keys[i]];\n}\nfunction $18c11f3350a906ea$var$resolve(id) {\n    var resolved = $18c11f3350a906ea$var$mapping[id];\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return resolved;\n}\n$18c11f3350a906ea$export$6503ec6e8aabbaf = $18c11f3350a906ea$var$register;\n$18c11f3350a906ea$export$f7ad0328861e2f03 = $18c11f3350a906ea$var$resolve;\n\n});\n\nvar $4700161487cf12af$exports = {};\n\n(parcelRequire(\"27Lyk\")).register(JSON.parse('{\"aKnk5\":\"index.58f0d801.js\",\"fM4Gy\":\"cubetexture.fb234566.jpg\"}'));\n\nfunction $9734543ae57c7d6c$export$ec5db564352962b(gl) {\n    const positionBuffer = $9734543ae57c7d6c$var$initPositionBuffer(gl);\n    const textureCoordBuffer = $9734543ae57c7d6c$var$initTextureBuffer(gl);\n    const indexBuffer = $9734543ae57c7d6c$var$initIndexBuffer(gl);\n    const normalBuffer = $9734543ae57c7d6c$var$initNormalBuffer(gl);\n    return {\n        position: positionBuffer,\n        normal: normalBuffer,\n        textureCoord: textureCoordBuffer,\n        indices: indexBuffer\n    };\n}\nfunction $9734543ae57c7d6c$var$initPositionBuffer(gl) {\n    // Create a buffer for the square's positions.\n    const positionBuffer = gl.createBuffer();\n    // Select the positionBuffer as the one to apply buffer\n    // operations to from here out.\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [\n        // Front face\n        -1,\n        -1,\n        1.0,\n        1.0,\n        -1,\n        1.0,\n        1.0,\n        1.0,\n        1.0,\n        -1,\n        1.0,\n        1.0,\n        // Back face\n        -1,\n        -1,\n        -1,\n        -1,\n        1.0,\n        -1,\n        1.0,\n        1.0,\n        -1,\n        1.0,\n        -1,\n        -1,\n        // Top face\n        -1,\n        1.0,\n        -1,\n        -1,\n        1.0,\n        1.0,\n        1.0,\n        1.0,\n        1.0,\n        1.0,\n        1.0,\n        -1,\n        // Bottom face\n        -1,\n        -1,\n        -1,\n        1.0,\n        -1,\n        -1,\n        1.0,\n        -1,\n        1.0,\n        -1,\n        -1,\n        1.0,\n        // Right face\n        1.0,\n        -1,\n        -1,\n        1.0,\n        1.0,\n        -1,\n        1.0,\n        1.0,\n        1.0,\n        1.0,\n        -1,\n        1.0,\n        // Left face\n        -1,\n        -1,\n        -1,\n        -1,\n        -1,\n        1.0,\n        -1,\n        1.0,\n        1.0,\n        -1,\n        1.0,\n        -1\n    ];\n    // Now pass the list of positions into WebGL to build the\n    // shape. We do this by creating a Float32Array from the\n    // JavaScript array, then use it to fill the current buffer.\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n    return positionBuffer;\n}\nfunction $9734543ae57c7d6c$var$initColorBuffer(gl) {\n    const faceColors = [\n        [\n            1.0,\n            1.0,\n            1.0,\n            1.0\n        ],\n        [\n            1.0,\n            0.0,\n            0.0,\n            1.0\n        ],\n        [\n            0.0,\n            1.0,\n            0.0,\n            1.0\n        ],\n        [\n            0.0,\n            0.0,\n            1.0,\n            1.0\n        ],\n        [\n            1.0,\n            1.0,\n            0.0,\n            1.0\n        ],\n        [\n            1.0,\n            0.0,\n            1.0,\n            1.0\n        ]\n    ];\n    // Convert the array of colors into a table for all the vertices.\n    var colors = [];\n    for(var j = 0; j < faceColors.length; ++j){\n        const c = faceColors[j];\n        // Repeat each color four times for the four vertices of the face\n        colors = colors.concat(c, c, c, c);\n    }\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\n    return colorBuffer;\n}\nfunction $9734543ae57c7d6c$var$initIndexBuffer(gl) {\n    const indexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n    // This array defines each face as two triangles, using the\n    // indices into the vertex array to specify each triangle's\n    // position.\n    const indices = [\n        0,\n        1,\n        2,\n        0,\n        2,\n        3,\n        4,\n        5,\n        6,\n        4,\n        6,\n        7,\n        8,\n        9,\n        10,\n        8,\n        10,\n        11,\n        12,\n        13,\n        14,\n        12,\n        14,\n        15,\n        16,\n        17,\n        18,\n        16,\n        18,\n        19,\n        20,\n        21,\n        22,\n        20,\n        22,\n        23\n    ];\n    // Now send the element array to GL\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n    return indexBuffer;\n}\nfunction $9734543ae57c7d6c$var$initTextureBuffer(gl) {\n    const textureCoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);\n    const textureCoordinates = [\n        // Front\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        1.0,\n        1.0,\n        0.0,\n        1.0,\n        // Back\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        1.0,\n        1.0,\n        0.0,\n        1.0,\n        // Top\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        1.0,\n        1.0,\n        0.0,\n        1.0,\n        // Bottom\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        1.0,\n        1.0,\n        0.0,\n        1.0,\n        // Right\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        1.0,\n        1.0,\n        0.0,\n        1.0,\n        // Left\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        1.0,\n        1.0,\n        0.0,\n        1.0\n    ];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\n    return textureCoordBuffer;\n}\nfunction $9734543ae57c7d6c$var$initNormalBuffer(gl) {\n    const normalBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);\n    const vertexNormals = [\n        // Front\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        0.0,\n        1.0,\n        // Back\n        0.0,\n        0.0,\n        -1,\n        0.0,\n        0.0,\n        -1,\n        0.0,\n        0.0,\n        -1,\n        0.0,\n        0.0,\n        -1,\n        // Top\n        0.0,\n        1.0,\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        // Bottom\n        0.0,\n        -1,\n        0.0,\n        0.0,\n        -1,\n        0.0,\n        0.0,\n        -1,\n        0.0,\n        0.0,\n        -1,\n        0.0,\n        // Right\n        1.0,\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        0.0,\n        1.0,\n        0.0,\n        0.0,\n        // Left\n        -1,\n        0.0,\n        0.0,\n        -1,\n        0.0,\n        0.0,\n        -1,\n        0.0,\n        0.0,\n        -1,\n        0.0,\n        0.0\n    ];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);\n    return normalBuffer;\n}\n\n\nfunction $34003bc5868ea94b$export$9ace2719e23fc1c2(gl, programInfo, buffers, texture, cubeRotation) {\n    gl.clearColor(0.0, 0.0, 0.0, 1.0) // Clear to black, fully opaque\n    ;\n    gl.clearDepth(1.0) // Clear everything\n    ;\n    gl.enable(gl.DEPTH_TEST) // Enable depth testing\n    ;\n    gl.depthFunc(gl.LEQUAL) // Near things obscure far things\n    ;\n    // Clear the canvas before we start drawing on it.\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    // Create a perspective matrix, a special matrix that is\n    // used to simulate the distortion of perspective in a camera.\n    // Our field of view is 45 degrees, with a width/height\n    // ratio that matches the display size of the canvas\n    // and we only want to see objects between 0.1 units\n    // and 100 units away from the camera.\n    const fieldOfView = 45 * Math.PI / 180 // in radians\n    ;\n    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\n    const zNear = 0.1;\n    const zFar = 100.0;\n    const projectionMatrix = mat4.create();\n    // note: glmatrix.js always has the first argument\n    // as the destination to receive the result.\n    mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);\n    // Set the drawing position to the \"identity\" point, which is\n    // the center of the scene.\n    const modelViewMatrix = mat4.create();\n    // Now move the drawing position a bit to where we want to\n    // start drawing the square.\n    mat4.translate(modelViewMatrix, modelViewMatrix, [\n        -0,\n        0.0,\n        -6\n    ]) // amount to translate\n    ;\n    mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation, [\n        0,\n        0,\n        1\n    ]) // axis to rotate around (Z)\n    ;\n    mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation * 0.7, [\n        0,\n        1,\n        0\n    ]) // axis to rotate around (Y)\n    ;\n    mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation * 0.3, [\n        1,\n        0,\n        0\n    ]) // axis to rotate around (X)\n    ;\n    const normalMatrix = mat4.create();\n    mat4.invert(normalMatrix, modelViewMatrix);\n    mat4.transpose(normalMatrix, normalMatrix);\n    // Tell WebGL how to pull out the positions from the position\n    // buffer into the vertexPosition attribute.\n    $34003bc5868ea94b$var$setPositionAttribute(gl, buffers, programInfo);\n    $34003bc5868ea94b$var$setTextureAttribute(gl, buffers, programInfo);\n    // Tell WebGL which indices to use to index the vertices\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\n    $34003bc5868ea94b$var$setNormalAttribute(gl, buffers, programInfo);\n    // Tell WebGL to use our program when drawing\n    gl.useProgram(programInfo.program);\n    // Set the shader uniforms\n    gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);\n    gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);\n    gl.uniformMatrix4fv(programInfo.uniformLocations.normalMatrix, false, normalMatrix);\n    // Tell WebGL we want to affect texture unit 0\n    gl.activeTexture(gl.TEXTURE0);\n    // Bind the texture to texture unit 0\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    // Tell the shader we bound the texture to texture unit 0\n    gl.uniform1i(programInfo.uniformLocations.uSampler, 0);\n    {\n        const vertexCount = 36;\n        const type = gl.UNSIGNED_SHORT;\n        const offset = 0;\n        gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\n    }\n}\n// Tell WebGL how to pull out the positions from the position\n// buffer into the vertexPosition attribute.\nfunction $34003bc5868ea94b$var$setPositionAttribute(gl, buffers, programInfo) {\n    const numComponents = 3;\n    const type = gl.FLOAT // the data in the buffer is 32bit floats\n    ;\n    const normalize = false // don't normalize\n    ;\n    const stride = 0 // how many bytes to get from one set of values to the next\n    ;\n    // 0 = use type and numComponents above\n    const offset = 0 // how many bytes inside the buffer to start from\n    ;\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);\n    gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset);\n    gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);\n}\n// Tell WebGL how to pull out the colors from the color buffer\n// into the vertexColor attribute.\nfunction $34003bc5868ea94b$var$setColorAttribute(gl, buffers, programInfo) {\n    const numComponents = 4;\n    const type = gl.FLOAT;\n    const normalize = false;\n    const stride = 0;\n    const offset = 0;\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);\n    gl.vertexAttribPointer(programInfo.attribLocations.vertexColor, numComponents, type, normalize, stride, offset);\n    gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);\n}\n// tell webgl how to pull out the texture coordinates from buffer\nfunction $34003bc5868ea94b$var$setTextureAttribute(gl, buffers, programInfo) {\n    const num = 2 // every coordinate composed of 2 values\n    ;\n    const type = gl.FLOAT // the data in the buffer is 32-bit float\n    ;\n    const normalize = false // don't normalize\n    ;\n    const stride = 0 // how many bytes to get from one set to the next\n    ;\n    const offset = 0 // how many bytes inside the buffer to start from\n    ;\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);\n    gl.vertexAttribPointer(programInfo.attribLocations.textureCoord, num, type, normalize, stride, offset);\n    gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);\n}\n// Tell WebGL how to pull out the normals from\n// the normal buffer into the vertexNormal attribute.\nfunction $34003bc5868ea94b$var$setNormalAttribute(gl, buffers, programInfo) {\n    const numComponents = 3;\n    const type = gl.FLOAT;\n    const normalize = false;\n    const stride = 0;\n    const offset = 0;\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);\n    gl.vertexAttribPointer(programInfo.attribLocations.vertexNormal, numComponents, type, normalize, stride, offset);\n    gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal);\n}\n\n\nvar $62e4266d682e15e4$exports = {};\n\n$62e4266d682e15e4$exports = new URL((parcelRequire(\"27Lyk\")).resolve(\"fM4Gy\"), import.meta.url).toString();\n\n\nlet $cd33d1601645a65e$var$cubeRotation = 0.0;\nlet $cd33d1601645a65e$var$deltaTime = 0;\n$cd33d1601645a65e$var$main();\nfunction $cd33d1601645a65e$var$main() {\n    const canvas = document.querySelector(\"#glcanvas\");\n    const gl = canvas.getContext(\"webgl\");\n    if (gl === null) {\n        alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\n        return;\n    }\n    // Vertex shader program\n    const vsSource = `\n  attribute vec4 aVertexPosition;\n  attribute vec3 aVertexNormal;\n  attribute vec2 aTextureCoord;\n\n  uniform mat4 uNormalMatrix;\n  uniform mat4 uModelViewMatrix;\n  uniform mat4 uProjectionMatrix;\n\n  varying highp vec2 vTextureCoord;\n  varying highp vec3 vLighting;\n\n  void main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n    vTextureCoord = aTextureCoord;\n\n    // Apply lighting effect\n\n    highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);\n    highp vec3 directionalLightColor = vec3(1, 1, 1);\n    highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));\n\n    highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);\n\n    highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);\n    vLighting = ambientLight + (directionalLightColor * directional);\n  }\n`;\n    // Fragment shader program\n    const fsSource = `\n  varying highp vec2 vTextureCoord;\n  varying highp vec3 vLighting;\n\n  uniform sampler2D uSampler;\n\n  void main(void) {\n    highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\n\n    gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a);\n  }\n`;\n    // Initialize a shader program this is where all the lighting\n    // for the vertices and so forth is established.\n    const shaderProgram = $cd33d1601645a65e$var$initShaderProgram(gl, vsSource, fsSource);\n    // Collect all the info needed to use the shader program.\n    // Look up which attributes our shader program is using\n    // for aVertexPosition, aVertexColor and also\n    // look up uniform locations.\n    const programInfo = {\n        program: shaderProgram,\n        attribLocations: {\n            vertexPosition: gl.getAttribLocation(shaderProgram, \"aVertexPosition\"),\n            vertexNormal: gl.getAttribLocation(shaderProgram, \"aVertexNormal\"),\n            textureCoord: gl.getAttribLocation(shaderProgram, \"aTextureCoord\")\n        },\n        uniformLocations: {\n            projectionMatrix: gl.getUniformLocation(shaderProgram, \"uProjectionMatrix\"),\n            modelViewMatrix: gl.getUniformLocation(shaderProgram, \"uModelViewMatrix\"),\n            normalMatrix: gl.getUniformLocation(shaderProgram, \"uNormalMatrix\"),\n            uSampler: gl.getUniformLocation(shaderProgram, \"uSampler\")\n        }\n    };\n    // Here's where we call the routine that builds all the\n    // objects we'll be drawing.\n    const buffers = (0, $9734543ae57c7d6c$export$ec5db564352962b)(gl);\n    // Load texture\n    const texture = $cd33d1601645a65e$var$loadTexture(gl, (0, (/*@__PURE__*/$parcel$interopDefault($62e4266d682e15e4$exports))));\n    // Flip image pixels into the bottom-to-top order that WebGL expects.\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    let then = 0;\n    // Draw the scene repeatedly\n    function render(now) {\n        now *= 0.001 // convert to seconds\n        ;\n        $cd33d1601645a65e$var$deltaTime = now - then;\n        then = now;\n        (0, $34003bc5868ea94b$export$9ace2719e23fc1c2)(gl, programInfo, buffers, texture, $cd33d1601645a65e$var$cubeRotation);\n        $cd33d1601645a65e$var$cubeRotation += $cd33d1601645a65e$var$deltaTime;\n        requestAnimationFrame(render);\n    }\n    requestAnimationFrame(render);\n}\n//\n// Initialize a shader program, so WebGL knows how to draw our data\n//\nfunction $cd33d1601645a65e$var$initShaderProgram(gl, vsSource, fsSource) {\n    const vertexShader = $cd33d1601645a65e$var$loadShader(gl, gl.VERTEX_SHADER, vsSource);\n    const fragmentShader = $cd33d1601645a65e$var$loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\n    // Create the shader program\n    const shaderProgram = gl.createProgram();\n    gl.attachShader(shaderProgram, vertexShader);\n    gl.attachShader(shaderProgram, fragmentShader);\n    gl.linkProgram(shaderProgram);\n    // If creating the shader program failed, alert\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n        alert(`Unable to initialize the shader program: ${gl.getProgramInfoLog(shaderProgram)}`);\n        return null;\n    }\n    return shaderProgram;\n}\n//\n// creates a shader of the given type, uploads the source and\n// compiles it.\n//\nfunction $cd33d1601645a65e$var$loadShader(gl, type, source) {\n    const shader = gl.createShader(type);\n    // Send the source to the shader object\n    gl.shaderSource(shader, source);\n    // Compile the shader program\n    gl.compileShader(shader);\n    // See if it compiled successfully\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        alert(`An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`);\n        gl.deleteShader(shader);\n        return null;\n    }\n    return shader;\n}\n//\n// Initialize a texture and load an image.\n// When the image finished loading copy it into the texture.\n//\nfunction $cd33d1601645a65e$var$loadTexture(gl, url) {\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    // Because images have to be downloaded over the internet\n    // they might take a moment until they are ready.\n    // Until then put a single pixel in the texture so we can\n    // use it immediately. When the image has finished downloading\n    // we'll update the texture with the contents of the image.\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const width = 1;\n    const height = 1;\n    const border = 0;\n    const srcFormat = gl.RGBA;\n    const srcType = gl.UNSIGNED_BYTE;\n    const pixel = new Uint8Array([\n        0,\n        0,\n        255,\n        255\n    ]) // opaque blue\n    ;\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);\n    const image = new Image();\n    image.onload = ()=>{\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, image);\n        // WebGL1 has different requirements for power of 2 images\n        // vs non power of 2 images so check if the image is a\n        // power of 2 in both dimensions.\n        if ($cd33d1601645a65e$var$isPowerOf2(image.width) && $cd33d1601645a65e$var$isPowerOf2(image.height)) // Yes, it's a power of 2. Generate mips.\n        gl.generateMipmap(gl.TEXTURE_2D);\n        else {\n            // No, it's not a power of 2. Turn off mips and set\n            // wrapping to clamp to edge\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        }\n    };\n    image.src = url;\n    return texture;\n}\nfunction $cd33d1601645a65e$var$isPowerOf2(value) {\n    return (value & value - 1) === 0;\n}\n\n\n//# sourceMappingURL=index.58f0d801.js.map\n","\"use strict\";\n\nvar mapping = {};\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping[id];\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return resolved;\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"aKnk5\\\":\\\"index.58f0d801.js\\\",\\\"fM4Gy\\\":\\\"cubetexture.fb234566.jpg\\\"}\"));","import { initBuffers } from \"./init-buffers.js\"\nimport { drawScene } from \"./draw-scene.js\"\nimport cubetexture from \"./cubetexture.jpg\"\n\nlet cubeRotation = 0.0\nlet deltaTime = 0\n\nmain()\n\nfunction main() {\n  const canvas = document.querySelector(\"#glcanvas\")\n  const gl = canvas.getContext(\"webgl\")\n\n  if (gl === null) {\n    alert(\n      \"Unable to initialize WebGL. Your browser or machine may not support it.\"\n    )\n    return\n  }\n\n  // Vertex shader program\n\n  const vsSource = `\n  attribute vec4 aVertexPosition;\n  attribute vec3 aVertexNormal;\n  attribute vec2 aTextureCoord;\n\n  uniform mat4 uNormalMatrix;\n  uniform mat4 uModelViewMatrix;\n  uniform mat4 uProjectionMatrix;\n\n  varying highp vec2 vTextureCoord;\n  varying highp vec3 vLighting;\n\n  void main(void) {\n    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n    vTextureCoord = aTextureCoord;\n\n    // Apply lighting effect\n\n    highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);\n    highp vec3 directionalLightColor = vec3(1, 1, 1);\n    highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));\n\n    highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);\n\n    highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);\n    vLighting = ambientLight + (directionalLightColor * directional);\n  }\n`;\n\n  // Fragment shader program\n\n  const fsSource = `\n  varying highp vec2 vTextureCoord;\n  varying highp vec3 vLighting;\n\n  uniform sampler2D uSampler;\n\n  void main(void) {\n    highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\n\n    gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a);\n  }\n`;\n\n\n\n  // Initialize a shader program this is where all the lighting\n  // for the vertices and so forth is established.\n  const shaderProgram = initShaderProgram(gl, vsSource, fsSource)\n\n  // Collect all the info needed to use the shader program.\n  // Look up which attributes our shader program is using\n  // for aVertexPosition, aVertexColor and also\n  // look up uniform locations.\n  const programInfo = {\n    program: shaderProgram,\n    attribLocations: {\n      vertexPosition: gl.getAttribLocation(shaderProgram, \"aVertexPosition\"),\n      vertexNormal: gl.getAttribLocation(shaderProgram, \"aVertexNormal\"),\n      textureCoord: gl.getAttribLocation(shaderProgram, \"aTextureCoord\"),\n    },\n    uniformLocations: {\n      projectionMatrix: gl.getUniformLocation(\n        shaderProgram,\n        \"uProjectionMatrix\"\n      ),\n      modelViewMatrix: gl.getUniformLocation(shaderProgram, \"uModelViewMatrix\"),\n      normalMatrix: gl.getUniformLocation(shaderProgram, \"uNormalMatrix\"),\n      uSampler: gl.getUniformLocation(shaderProgram, \"uSampler\"),\n    },\n  }\n\n  // Here's where we call the routine that builds all the\n  // objects we'll be drawing.\n  const buffers = initBuffers(gl)\n\n  // Load texture\n  const texture = loadTexture(gl, cubetexture)\n  // Flip image pixels into the bottom-to-top order that WebGL expects.\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true)\n\n  let then = 0\n\n  // Draw the scene repeatedly\n  function render(now) {\n    now *= 0.001 // convert to seconds\n    deltaTime = now - then\n    then = now\n\n    drawScene(gl, programInfo, buffers, texture, cubeRotation)\n    cubeRotation += deltaTime\n\n    requestAnimationFrame(render)\n  }\n  requestAnimationFrame(render)\n}\n\n//\n// Initialize a shader program, so WebGL knows how to draw our data\n//\nfunction initShaderProgram(gl, vsSource, fsSource) {\n  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource)\n  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource)\n\n  // Create the shader program\n\n  const shaderProgram = gl.createProgram()\n  gl.attachShader(shaderProgram, vertexShader)\n  gl.attachShader(shaderProgram, fragmentShader)\n  gl.linkProgram(shaderProgram)\n\n  // If creating the shader program failed, alert\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    alert(\n      `Unable to initialize the shader program: ${gl.getProgramInfoLog(\n        shaderProgram\n      )}`\n    )\n    return null\n  }\n\n  return shaderProgram\n}\n\n//\n// creates a shader of the given type, uploads the source and\n// compiles it.\n//\nfunction loadShader(gl, type, source) {\n  const shader = gl.createShader(type)\n\n  // Send the source to the shader object\n\n  gl.shaderSource(shader, source)\n\n  // Compile the shader program\n\n  gl.compileShader(shader)\n\n  // See if it compiled successfully\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    alert(\n      `An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`\n    )\n    gl.deleteShader(shader)\n    return null\n  }\n\n  return shader\n}\n\n//\n// Initialize a texture and load an image.\n// When the image finished loading copy it into the texture.\n//\nfunction loadTexture(gl, url) {\n  const texture = gl.createTexture()\n  gl.bindTexture(gl.TEXTURE_2D, texture)\n\n  // Because images have to be downloaded over the internet\n  // they might take a moment until they are ready.\n  // Until then put a single pixel in the texture so we can\n  // use it immediately. When the image has finished downloading\n  // we'll update the texture with the contents of the image.\n  const level = 0\n  const internalFormat = gl.RGBA\n  const width = 1\n  const height = 1\n  const border = 0\n  const srcFormat = gl.RGBA\n  const srcType = gl.UNSIGNED_BYTE\n  const pixel = new Uint8Array([0, 0, 255, 255]) // opaque blue\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    level,\n    internalFormat,\n    width,\n    height,\n    border,\n    srcFormat,\n    srcType,\n    pixel\n  )\n\n  const image = new Image()\n  image.onload = () => {\n    gl.bindTexture(gl.TEXTURE_2D, texture)\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      level,\n      internalFormat,\n      srcFormat,\n      srcType,\n      image\n    )\n    // WebGL1 has different requirements for power of 2 images\n    // vs non power of 2 images so check if the image is a\n    // power of 2 in both dimensions.\n    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {\n      // Yes, it's a power of 2. Generate mips.\n      gl.generateMipmap(gl.TEXTURE_2D)\n    } else {\n      // No, it's not a power of 2. Turn off mips and set\n      // wrapping to clamp to edge\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)\n    }\n  }\n  image.src = url\n\n  return texture\n}\n\nfunction isPowerOf2(value) {\n  return (value & (value - 1)) === 0\n}","function initBuffers(gl) {\n  const positionBuffer = initPositionBuffer(gl)\n\n  const textureCoordBuffer = initTextureBuffer(gl)\n\n  const indexBuffer = initIndexBuffer(gl)\n\n  const normalBuffer = initNormalBuffer(gl)\n\n  return {\n    position: positionBuffer,\n    normal: normalBuffer,\n    textureCoord: textureCoordBuffer,\n    indices: indexBuffer,\n  }\n}\n\nfunction initPositionBuffer(gl) {\n  // Create a buffer for the square's positions.\n  const positionBuffer = gl.createBuffer()\n\n  // Select the positionBuffer as the one to apply buffer\n  // operations to from here out.\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\n\n  const positions = [\n    // Front face\n    -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0,\n\n    // Back face\n    -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0,\n\n    // Top face\n    -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0,\n\n    // Bottom face\n    -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0,\n\n    // Right face\n    1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0,\n\n    // Left face\n    -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0,\n  ]\n\n  // Now pass the list of positions into WebGL to build the\n  // shape. We do this by creating a Float32Array from the\n  // JavaScript array, then use it to fill the current buffer.\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)\n\n  return positionBuffer\n}\n\nfunction initColorBuffer(gl) {\n  const faceColors = [\n    [1.0, 1.0, 1.0, 1.0], // Front face: white\n    [1.0, 0.0, 0.0, 1.0], // Back face: red\n    [0.0, 1.0, 0.0, 1.0], // Top face: green\n    [0.0, 0.0, 1.0, 1.0], // Bottom face: blue\n    [1.0, 1.0, 0.0, 1.0], // Right face: yellow\n    [1.0, 0.0, 1.0, 1.0], // Left face: purple\n  ]\n\n  // Convert the array of colors into a table for all the vertices.\n\n  var colors = []\n\n  for (var j = 0; j < faceColors.length; ++j) {\n    const c = faceColors[j]\n    // Repeat each color four times for the four vertices of the face\n    colors = colors.concat(c, c, c, c)\n  }\n\n  const colorBuffer = gl.createBuffer()\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer)\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW)\n\n  return colorBuffer\n}\n\nfunction initIndexBuffer(gl) {\n  const indexBuffer = gl.createBuffer()\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)\n\n  // This array defines each face as two triangles, using the\n  // indices into the vertex array to specify each triangle's\n  // position.\n\n  const indices = [\n    0,\n    1,\n    2,\n    0,\n    2,\n    3, // front\n    4,\n    5,\n    6,\n    4,\n    6,\n    7, // back\n    8,\n    9,\n    10,\n    8,\n    10,\n    11, // top\n    12,\n    13,\n    14,\n    12,\n    14,\n    15, // bottom\n    16,\n    17,\n    18,\n    16,\n    18,\n    19, // right\n    20,\n    21,\n    22,\n    20,\n    22,\n    23, // left\n  ]\n\n  // Now send the element array to GL\n\n  gl.bufferData(\n    gl.ELEMENT_ARRAY_BUFFER,\n    new Uint16Array(indices),\n    gl.STATIC_DRAW\n  )\n\n  return indexBuffer\n}\n\nfunction initTextureBuffer(gl) {\n  const textureCoordBuffer = gl.createBuffer()\n  gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer)\n\n  const textureCoordinates = [\n    // Front\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    // Back\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    // Top\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    // Bottom\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    // Right\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    // Left\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n  ]\n\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    new Float32Array(textureCoordinates),\n    gl.STATIC_DRAW\n  )\n\n  return textureCoordBuffer\n}\n\nfunction initNormalBuffer(gl) {\n  const normalBuffer = gl.createBuffer()\n  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer)\n\n  const vertexNormals = [\n    // Front\n    0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,\n\n    // Back\n    0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0,\n\n    // Top\n    0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,\n\n    // Bottom\n    0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,\n\n    // Right\n    1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,\n\n    // Left\n    -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0,\n  ]\n\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    new Float32Array(vertexNormals),\n    gl.STATIC_DRAW\n  )\n\n  return normalBuffer\n}\n\nexport { initBuffers }","function drawScene(gl, programInfo, buffers, texture, cubeRotation) {\n  gl.clearColor(0.0, 0.0, 0.0, 1.0) // Clear to black, fully opaque\n  gl.clearDepth(1.0) // Clear everything\n  gl.enable(gl.DEPTH_TEST) // Enable depth testing\n  gl.depthFunc(gl.LEQUAL) // Near things obscure far things\n\n  // Clear the canvas before we start drawing on it.\n\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n\n  // Create a perspective matrix, a special matrix that is\n  // used to simulate the distortion of perspective in a camera.\n  // Our field of view is 45 degrees, with a width/height\n  // ratio that matches the display size of the canvas\n  // and we only want to see objects between 0.1 units\n  // and 100 units away from the camera.\n\n  const fieldOfView = (45 * Math.PI) / 180 // in radians\n  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight\n  const zNear = 0.1\n  const zFar = 100.0\n  const projectionMatrix = mat4.create()\n\n  // note: glmatrix.js always has the first argument\n  // as the destination to receive the result.\n  mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar)\n\n  // Set the drawing position to the \"identity\" point, which is\n  // the center of the scene.\n  const modelViewMatrix = mat4.create()\n\n  // Now move the drawing position a bit to where we want to\n  // start drawing the square.\n  mat4.translate(\n    modelViewMatrix, // destination matrix\n    modelViewMatrix, // matrix to translate\n    [-0.0, 0.0, -6.0]\n  ) // amount to translate\n\n  mat4.rotate(\n    modelViewMatrix, // destination matrix\n    modelViewMatrix, // matrix to rotate\n    cubeRotation, // amount to rotate in radians\n    [0, 0, 1]\n  ) // axis to rotate around (Z)\n  mat4.rotate(\n    modelViewMatrix, // destination matrix\n    modelViewMatrix, // matrix to rotate\n    cubeRotation * 0.7, // amount to rotate in radians\n    [0, 1, 0]\n  ) // axis to rotate around (Y)\n  mat4.rotate(\n    modelViewMatrix, // destination matrix\n    modelViewMatrix, // matrix to rotate\n    cubeRotation * 0.3, // amount to rotate in radians\n    [1, 0, 0]\n  ) // axis to rotate around (X)\n\n  const normalMatrix = mat4.create()\n  mat4.invert(normalMatrix, modelViewMatrix)\n  mat4.transpose(normalMatrix, normalMatrix)\n\n  // Tell WebGL how to pull out the positions from the position\n  // buffer into the vertexPosition attribute.\n  setPositionAttribute(gl, buffers, programInfo)\n\n  setTextureAttribute(gl, buffers, programInfo)\n\n  // Tell WebGL which indices to use to index the vertices\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices)\n\n  setNormalAttribute(gl, buffers, programInfo)\n\n  // Tell WebGL to use our program when drawing\n  gl.useProgram(programInfo.program)\n\n  // Set the shader uniforms\n  gl.uniformMatrix4fv(\n    programInfo.uniformLocations.projectionMatrix,\n    false,\n    projectionMatrix\n  )\n  gl.uniformMatrix4fv(\n    programInfo.uniformLocations.modelViewMatrix,\n    false,\n    modelViewMatrix\n  )\n  gl.uniformMatrix4fv(\n    programInfo.uniformLocations.normalMatrix,\n    false,\n    normalMatrix\n  )\n\n  // Tell WebGL we want to affect texture unit 0\n  gl.activeTexture(gl.TEXTURE0)\n\n  // Bind the texture to texture unit 0\n  gl.bindTexture(gl.TEXTURE_2D, texture)\n\n  // Tell the shader we bound the texture to texture unit 0\n  gl.uniform1i(programInfo.uniformLocations.uSampler, 0)\n\n  {\n    const vertexCount = 36\n    const type = gl.UNSIGNED_SHORT\n    const offset = 0\n    gl.drawElements(gl.TRIANGLES, vertexCount, type, offset)\n  }\n}\n\n// Tell WebGL how to pull out the positions from the position\n// buffer into the vertexPosition attribute.\nfunction setPositionAttribute(gl, buffers, programInfo) {\n  const numComponents = 3\n  const type = gl.FLOAT // the data in the buffer is 32bit floats\n  const normalize = false // don't normalize\n  const stride = 0 // how many bytes to get from one set of values to the next\n  // 0 = use type and numComponents above\n  const offset = 0 // how many bytes inside the buffer to start from\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position)\n  gl.vertexAttribPointer(\n    programInfo.attribLocations.vertexPosition,\n    numComponents,\n    type,\n    normalize,\n    stride,\n    offset\n  )\n  gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition)\n}\n\n// Tell WebGL how to pull out the colors from the color buffer\n// into the vertexColor attribute.\nfunction setColorAttribute(gl, buffers, programInfo) {\n  const numComponents = 4\n  const type = gl.FLOAT\n  const normalize = false\n  const stride = 0\n  const offset = 0\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color)\n  gl.vertexAttribPointer(\n    programInfo.attribLocations.vertexColor,\n    numComponents,\n    type,\n    normalize,\n    stride,\n    offset\n  )\n  gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor)\n}\n\n// tell webgl how to pull out the texture coordinates from buffer\nfunction setTextureAttribute(gl, buffers, programInfo) {\n  const num = 2 // every coordinate composed of 2 values\n  const type = gl.FLOAT // the data in the buffer is 32-bit float\n  const normalize = false // don't normalize\n  const stride = 0 // how many bytes to get from one set to the next\n  const offset = 0 // how many bytes inside the buffer to start from\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord)\n  gl.vertexAttribPointer(\n    programInfo.attribLocations.textureCoord,\n    num,\n    type,\n    normalize,\n    stride,\n    offset\n  )\n  gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord)\n}\n\n// Tell WebGL how to pull out the normals from\n// the normal buffer into the vertexNormal attribute.\nfunction setNormalAttribute(gl, buffers, programInfo) {\n  const numComponents = 3\n  const type = gl.FLOAT\n  const normalize = false\n  const stride = 0\n  const offset = 0\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal)\n  gl.vertexAttribPointer(\n    programInfo.attribLocations.vertexNormal,\n    numComponents,\n    type,\n    normalize,\n    stride,\n    offset\n  )\n  gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal)\n}\n\nexport { drawScene }","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"fM4Gy\")).toString();"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","pairs","keys","i","length","resolved","JSON","parse","$62e4266d682e15e4$exports","URL","resolve","url","toString","$cd33d1601645a65e$var$cubeRotation","$cd33d1601645a65e$var$deltaTime","$cd33d1601645a65e$var$loadShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","deleteShader","$cd33d1601645a65e$var$main","a","canvas","document","querySelector","getContext","vsSource","fsSource","shaderProgram","$cd33d1601645a65e$var$initShaderProgram","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","programInfo","program","attribLocations","vertexPosition","getAttribLocation","vertexNormal","textureCoord","uniformLocations","projectionMatrix","getUniformLocation","modelViewMatrix","normalMatrix","uSampler","buffers","positionBuffer","$9734543ae57c7d6c$var$initPositionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","textureCoordBuffer","$9734543ae57c7d6c$var$initTextureBuffer","indexBuffer","$9734543ae57c7d6c$var$initIndexBuffer","ELEMENT_ARRAY_BUFFER","Uint16Array","normalBuffer","$9734543ae57c7d6c$var$initNormalBuffer","position","normal","indices","texture","$cd33d1601645a65e$var$loadTexture","createTexture","bindTexture","TEXTURE_2D","internalFormat","RGBA","srcFormat","srcType","UNSIGNED_BYTE","pixel","Uint8Array","texImage2D","image","Image","onload","value","$cd33d1601645a65e$var$isPowerOf2","width","height","generateMipmap","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","src","__esModule","default","pixelStorei","UNPACK_FLIP_Y_WEBGL","then","requestAnimationFrame","render","now","cubeRotation","clearColor","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","aspect","clientWidth","clientHeight","mat4","create","perspective","Math","PI","translate","rotate","invert","transpose","FLOAT","vertexAttribPointer","enableVertexAttribArray","$34003bc5868ea94b$var$setTextureAttribute","$34003bc5868ea94b$var$setNormalAttribute","useProgram","uniformMatrix4fv","activeTexture","TEXTURE0","uniform1i","UNSIGNED_SHORT","drawElements","TRIANGLES"],"version":3,"file":"index.58f0d801.js.map"}